import requests
import sqlite3
from urllib.parse import urljoin, urlparse

# ---------- DB ----------
def log_vulnerability(url, vuln_type, payload):
    conn = sqlite3.connect("vulnerabilities.db")
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS vulnerabilities (
            id INTEGER PRIMARY KEY,
            url TEXT,
            type TEXT,
            payload TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    """)
    cur.execute("INSERT INTO vulnerabilities (url, type, payload) VALUES (?, ?, ?)",
                (url, vuln_type, payload))
    conn.commit()
    conn.close()

# ---------- HTTP helper ----------
def send(url, method="GET", data=None, timeout=8):
    method = (method or "GET").upper()
    if method == "POST":
        return requests.post(url, data=data or {}, timeout=timeout, allow_redirects=True)
    else:
        return requests.get(url, params=data or {}, timeout=timeout, allow_redirects=True)

# ---------- XSS ----------
def test_xss(target_url, form_action, input_name, method="GET"):
    payloads = [
        "<script>alert('XSS')</script>",
        "\"'><img src=x onerror=alert('XSS')>"
    ]
    target = urljoin(target_url, form_action or "")
    for payload in payloads:
        try:
            data = {input_name: payload}
            r = send(target, method, data)
            if payload in r.text:
                print(f"[XSS] {target} param={input_name}")
                log_vulnerability(target, "XSS", f"{input_name}={payload}")
                return True
        except requests.RequestException as e:
            print(f"[-] XSS error @ {target}: {e}")
    return False

# ---------- SQLi ----------
def test_sqli(target_url, form_action, input_name, method="GET"):
    payloads = [
        "' OR '1'='1 -- ",
        "\" OR \"1\"=\"1\" -- ",
        "' UNION SELECT NULL,NULL -- ",
        "'; WAITFOR DELAY '0:0:2'--"
    ]
    error_signatures = [
        "you have an error in your sql syntax",
        "warning: mysql",
        "unclosed quotation mark after the character string",
        "pg_query()", "postgresql", "sqlstate",
        "odbc", "sqlite", "mysql_fetch", "sql syntax"
    ]
    target = urljoin(target_url, form_action or "")
    for payload in payloads:
        try:
            data = {input_name: payload}
            r = send(target, method, data)
            body = r.text.lower()
            if any(sig in body for sig in error_signatures):
                print(f"[SQLi] {target} param={input_name}")
                log_vulnerability(target, "SQL Injection", f"{input_name}={payload}")
                return True
        except requests.RequestException as e:
            print(f"[-] SQLi error @ {target}: {e}")
    return False

# ---------- Security Headers ----------
def check_security_headers(target_url):
    """
    Checks for common missing security headers:
    - Content-Security-Policy
    - X-Frame-Options
    - X-Content-Type-Options
    - Referrer-Policy
    - Permissions-Policy
    - Strict-Transport-Security (only applicable on HTTPS)
    """
    try:
        r = requests.get(target_url, timeout=8, allow_redirects=True)
        headers = {k.lower(): v for k, v in r.headers.items()}
        scheme = urlparse(r.url).scheme.lower()

        required = [
            "content-security-policy",
            "x-frame-options",
            "x-content-type-options",
            "referrer-policy",
            "permissions-policy",
        ]
        for h in required:
            if h not in headers:
                log_vulnerability(r.url, "Missing Security Header", h)

        # HSTS only meaningful over HTTPS
        if scheme == "https" and "strict-transport-security" not in headers:
            log_vulnerability(r.url, "Missing Security Header", "strict-transport-security")

        print(f"[Headers] checked {r.url}")
        return True
    except requests.RequestException as e:
        print(f"[-] Header check error @ {target_url}: {e}")
        return False

# ---------- Standalone quick test ----------
if __name__ == "__main__":
    # Example: quick manual run
    url = "http://testphp.vulnweb.com/login.php"
    test_xss(url, "/login.php", "username", "POST")
    test_sqli(url, "/login.php", "username", "POST")
    check_security_headers(url)
